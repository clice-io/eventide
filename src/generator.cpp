#include <cerrno>
#include <cstdio>
#include <cstring>
#include <print>
#include <string_view>
#include <vector>

#include "uv.h"

namespace {

struct entry {
    std::string_view name;
    bool as_class;
    std::size_t size;
    std::size_t align;
};

constexpr std::string_view sanitize(std::string_view name) {
    if(name.starts_with("uv_")) {
        name.remove_prefix(3);
    }
    if(name.ends_with("_t")) {
        name.remove_suffix(2);
    }
    return name;
}

bool use_class(std::string_view name) {
    return name == "event_loop" || name == "pipe" || name == "tcp_socket" || name == "udp_socket" ||
           name == "console";
}

void emit_layout(std::FILE* out, const entry& e) {
    std::fprintf(out,
                 "template <> struct layout<%.*s> {\n",
                 static_cast<int>(e.name.size()),
                 e.name.data());
    std::fprintf(out, "    constexpr static std::size_t size = %zu;\n", e.size);
    std::fprintf(out, "    constexpr static std::size_t align = %zu;\n", e.align);
    std::fputs("};\n\n", out);
}

template <typename T>
void add_entry(std::vector<entry>& entries, std::string_view uv_name, std::string_view alias = "") {
    const auto name = alias.empty() ? sanitize(uv_name) : alias;
    entries.push_back(entry{
        .name = name,
        .as_class = use_class(name),
        .size = sizeof(T),
        .align = alignof(T),
    });
}

}  // namespace

int main(int argc, char** argv) {
    if(argc != 2) {
        std::println(stderr, "Usage: {} <output file>", argv[0]);
        return 1;
    }

    std::FILE* out = std::fopen(argv[1], "w");
    if(out == nullptr) {
        std::println(stderr, "Failed to open {}: {}", argv[1], std::strerror(errno));
        return 1;
    }

    std::vector<entry> entries;
    entries.reserve(42);
    add_entry<uv_loop_t>(entries, "uv_loop_t", "event_loop");
    add_entry<uv_pipe_t>(entries, "uv_pipe_t", "pipe");
    add_entry<uv_tcp_t>(entries, "uv_tcp_t", "tcp_socket");
    add_entry<uv_udp_t>(entries, "uv_udp_t", "udp_socket");
    add_entry<uv_tty_t>(entries, "uv_tty_t", "console");
    add_entry<uv_poll_t>(entries, "uv_poll_t");
    add_entry<uv_timer_t>(entries, "uv_timer_t");
    add_entry<uv_prepare_t>(entries, "uv_prepare_t");
    add_entry<uv_check_t>(entries, "uv_check_t");
    add_entry<uv_idle_t>(entries, "uv_idle_t");
    add_entry<uv_async_t>(entries, "uv_async_t");
    add_entry<uv_process_t>(entries, "uv_process_t");
    add_entry<uv_signal_t>(entries, "uv_signal_t");
    add_entry<uv_fs_event_t>(entries, "uv_fs_event_t");
    add_entry<uv_fs_poll_t>(entries, "uv_fs_poll_t");
    add_entry<uv_req_t>(entries, "uv_req_t");
    add_entry<uv_getaddrinfo_t>(entries, "uv_getaddrinfo_t");
    add_entry<uv_getnameinfo_t>(entries, "uv_getnameinfo_t");
    add_entry<uv_shutdown_t>(entries, "uv_shutdown_t");
    add_entry<uv_write_t>(entries, "uv_write_t", "write_req");
    add_entry<uv_connect_t>(entries, "uv_connect_t");
    add_entry<uv_udp_send_t>(entries, "uv_udp_send_t");
    add_entry<uv_fs_t>(entries, "uv_fs_t");
    add_entry<uv_work_t>(entries, "uv_work_t");
    add_entry<uv_random_t>(entries, "uv_random_t");
    add_entry<uv_dirent_t>(entries, "uv_dirent_t");
    add_entry<uv_dir_t>(entries, "uv_dir_t");
    add_entry<uv_buf_t>(entries, "uv_buf_t");
    add_entry<uv_stdio_container_t>(entries, "uv_stdio_container_t");
    add_entry<uv_process_options_t>(entries, "uv_process_options_t");
    add_entry<uv_cpu_times_s>(entries, "uv_cpu_times_s");
    add_entry<uv_cpu_info_t>(entries, "uv_cpu_info_t");
    add_entry<uv_interface_address_t>(entries, "uv_interface_address_t");
    add_entry<uv_passwd_t>(entries, "uv_passwd_t");
    add_entry<uv_group_t>(entries, "uv_group_t");
    add_entry<uv_utsname_t>(entries, "uv_utsname_t");
    add_entry<uv_statfs_t>(entries, "uv_statfs_t");
    add_entry<uv_metrics_t>(entries, "uv_metrics_t");
    add_entry<uv_env_item_t>(entries, "uv_env_item_t");
    add_entry<uv_thread_options_t>(entries, "uv_thread_options_t");

    std::fputs("// Auto-generated by src/generator.cpp. DO NOT EDIT.\n", out);
    std::fputs("#pragma once\n", out);
    std::fputs("#include <cstddef>\n\n", out);
    std::fputs("namespace eventide {\n\n", out);
    std::fputs("template <typename T> struct layout;\n\n", out);
    for(const auto& e: entries) {
        std::fprintf(out,
                     "%s %.*s;\n",
                     e.as_class ? "class" : "struct",
                     static_cast<int>(e.name.size()),
                     e.name.data());
    }

    std::fputc('\n', out);

    for(const auto& e: entries) {
        emit_layout(out, e);
    }

    std::fputs("}  // namespace eventide\n", out);

    return 0;
}
